use crate::{FuncId, Label, Prop, TypeId, Value};

struct Builder {}

impl Builder {
    // fn add(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn sub(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn mul(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn div(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn not(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn neg(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn eq(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn neq(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn gt(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn lt(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn gt_eq(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn lt_eq(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn push(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn call(&mut self, func: FuncId, args: &[Value]) -> Value {}
    // fn assign(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn ref_assign(&mut self, lhs: Value, rhs: Value) -> Value {}
    // fn aggregate(&mut self, values: &[Value]) -> Value {}
    // fn name(&mut self, value: Value, ty: TypeId) -> Value {}
    // fn vector(&mut self, values: &[Value]) -> Value {}
    // fn get_prop(&mut self, value: Value, prop: Prop) -> Value {}
    // fn ref_prop(&mut self, value: Value, prop: Prop) -> Value {}
    // fn branch(&mut self, condition: Value, true_label: Label, false_label: Label) -> Value {}
    // fn jump(&mut self, label: Label) -> Value {}
    // fn ret(&mut self, value: Value) -> Value {}
}
